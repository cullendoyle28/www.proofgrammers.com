---
title: "Similarities and Differences between Recognition and Decision"
description: "Explore Recognition and Decision"
date: "2025-10-28"
date-format: long
author: Cullen Doyle, Issei Hasegawa, Preston Smith
execute:
  echo: true
format:
  revealjs:
    theme: default
    css: ../../../css/styles.css
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Recognition

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 
- {{< iconify fa6-solid lightbulb >}} **What is "Recognition"?**
    - A language or decision problem can correctly decide all positive instances.
    - Either rejects and halts or loops forever when the string is not in
      the language (negative instance).
    - **Example**: A C++ compiler(g++) checks whether a program is syntactically
      correct. If the syntax is valid → it halts and accepts. If invalid →
      it may reject with an error or keep processing indefinitely.
:::

---

# Decision

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 
- {{< iconify fa6-solid lightbulb >}} **What is Decision?**
    - Accepts and halts when the string is in the
      language (positive instance).
    - Rejects and halts when the string is not in the
      language (negative instance).
:::

---

# Similarities & Differences

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 
- {{< iconify fa6-solid lightbulb >}} **What are Similarities & Differences?**
    - Similarities
      - Both guarantee correct acceptance for “Yes” instances.
      - Both are defined using Turing machines.

    - Differences
      - Decision "Always" halts in finite time, while Recognition
        "May not" halt for some inputs.
      - Decision corresponds to both ‘Yes’ and ‘No’ cases, while Recognition
        corresponds only to the ‘Yes’ case.
:::

---

# Recognition is Easier than Decision

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 
- {{< iconify fa6-solid lightbulb >}} **Why Recognition is Easier than Decision?**
    - Recognition try to find only positive instance; it does not care about 
      Negative instance and infinite loop. 
    - Decision try to find all possible case; it must correctly distinguish
      all cases (both yes- and no-instances)
:::

---

# What is RecYesOnString?

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 
- {{< iconify fa6-solid lightbulb >}} **What is theory of computation?**
    - Understanding what can be computed
    - Analyzing computational complexity
    - Proving limits of computation
    - "Proofgrammers" combine *proofs* and *programming*
:::

---

# RecYesOnString Program

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 
- {{< iconify fa6-solid lightbulb >}} **What is theory of computation?**
    - Understanding what can be computed
    - Analyzing computational complexity
    - Proving limits of computation
    - "Proofgrammers" combine *proofs* and *programming*
:::

---

# Recognizes, but Does Not Decide

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 
- {{< iconify fa6-solid lightbulb >}} **What is theory of computation?**
    - Understanding what can be computed
    - Analyzing computational complexity
    - Proving limits of computation
    - "Proofgrammers" combine *proofs* and *programming*
:::

---

# Conclusion

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 
- {{< iconify fa6-solid lightbulb >}} **What is theory of computation?**
    - Understanding what can be computed
    - Analyzing computational complexity
    - Proving limits of computation
    - "Proofgrammers" combine *proofs* and *programming*
:::

---